{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\mich5\\\\Documents\\\\JavaScript\\\\React\\\\W1D3\\\\react-fetch-crud\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\mich5\\\\Documents\\\\JavaScript\\\\React\\\\W1D3\\\\react-fetch-crud\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"C:\\\\Users\\\\mich5\\\\Documents\\\\JavaScript\\\\React\\\\W1D3\\\\react-fetch-crud\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\mich5\\\\Documents\\\\JavaScript\\\\React\\\\W1D3\\\\react-fetch-crud\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nvar URL = \"http://localhost:3456/api\"; // The two methods below, are the utility-methods given here (use them if you like, and if you do, bookmark the \n// document)://https://docs.google.com/document/d/1hF9P65v_AJKCjol_gFkm3oZ1eVTuOKc15V6pcb3iFa8/edit?usp=sharing \n\nfunction makeOptions(method, body) {\n  var opts = {\n    method: method,\n    headers: {\n      \"Content-type\": \"application/json\"\n    }\n  };\n\n  if (body) {\n    opts.body = JSON.stringify(body);\n  }\n\n  return opts;\n}\n\nfunction handleHttpErrors(res) {\n  if (!res.ok) {\n    return Promise.reject({\n      status: res.status,\n      fullError: res.json()\n    });\n  }\n\n  return res.json();\n}\n\nvar DataFacade =\n/*#__PURE__*/\nfunction () {\n  function DataFacade() {\n    _classCallCheck(this, DataFacade);\n  }\n\n  _createClass(DataFacade, [{\n    key: \"getPersons\",\n\n    /*\r\n    OBSERVE-1: This returns a promise, NOT the actual data, You must handle asynchronicity in your client code\r\n    OBSERVE-2: To \"simplify\" how to handle asynchronicity you can use async/await as sketched in the example below*/\n    // In order to use await, a method must be \"marked\" with async\n    value: function () {\n      var _getPersons = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return fetch(URL).then(handleHttpErrors);\n\n              case 2:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function getPersons() {\n        return _getPersons.apply(this, arguments);\n      }\n\n      return getPersons;\n    }()\n  }]);\n\n  return DataFacade;\n}();\n\nexport default new DataFacade();","map":{"version":3,"sources":["C:\\Users\\mich5\\Documents\\JavaScript\\React\\W1D3\\react-fetch-crud\\src\\dataFacade.js"],"names":["URL","makeOptions","method","body","opts","headers","JSON","stringify","handleHttpErrors","res","ok","Promise","reject","status","fullError","json","DataFacade","fetch","then"],"mappings":";;;;AAAA,IAAIA,GAAG,GAAG,2BAAV,C,CAEA;AACA;;AAEA,SAASC,WAAT,CAAqBC,MAArB,EAA6BC,IAA7B,EAAmC;AACjC,MAAIC,IAAI,GAAG;AACTF,IAAAA,MAAM,EAAEA,MADC;AAETG,IAAAA,OAAO,EAAE;AACP,sBAAgB;AADT;AAFA,GAAX;;AAMA,MAAIF,IAAJ,EAAU;AACRC,IAAAA,IAAI,CAACD,IAAL,GAAYG,IAAI,CAACC,SAAL,CAAeJ,IAAf,CAAZ;AACD;;AACD,SAAOC,IAAP;AACD;;AAED,SAASI,gBAAT,CAA0BC,GAA1B,EAA+B;AAC7B,MAAI,CAACA,GAAG,CAACC,EAAT,EAAa;AACX,WAAOC,OAAO,CAACC,MAAR,CAAe;AAAEC,MAAAA,MAAM,EAAEJ,GAAG,CAACI,MAAd;AAAsBC,MAAAA,SAAS,EAAEL,GAAG,CAACM,IAAJ;AAAjC,KAAf,CAAP;AACD;;AACD,SAAON,GAAG,CAACM,IAAJ,EAAP;AACD;;IAEKC,U;;;;;;;;;;AAEJ;;;AAIA;;;;;;;;;;uBAEeC,KAAK,CAACjB,GAAD,CAAL,CAAWkB,IAAX,CAAgBV,gBAAhB,C;;;;;;;;;;;;;;;;;;;;;;;;AAKjB,eAAe,IAAIQ,UAAJ,EAAf","sourcesContent":["let URL = \"http://localhost:3456/api\";\r\n\r\n// The two methods below, are the utility-methods given here (use them if you like, and if you do, bookmark the \r\n// document)://https://docs.google.com/document/d/1hF9P65v_AJKCjol_gFkm3oZ1eVTuOKc15V6pcb3iFa8/edit?usp=sharing \r\n\r\nfunction makeOptions(method, body) {\r\n  var opts = {\r\n    method: method,\r\n    headers: {\r\n      \"Content-type\": \"application/json\"\r\n    }\r\n  }\r\n  if (body) {\r\n    opts.body = JSON.stringify(body);\r\n  }\r\n  return opts;\r\n}\r\n\r\nfunction handleHttpErrors(res) {\r\n  if (!res.ok) {\r\n    return Promise.reject({ status: res.status, fullError: res.json() })\r\n  }\r\n  return res.json();\r\n}\r\n\r\nclass DataFacade {\r\n\r\n  /*\r\n  OBSERVE-1: This returns a promise, NOT the actual data, You must handle asynchronicity in your client code\r\n  OBSERVE-2: To \"simplify\" how to handle asynchronicity you can use async/await as sketched in the example below*/\r\n\r\n  // In order to use await, a method must be \"marked\" with async\r\n  async getPersons() {\r\n    return await fetch(URL).then(handleHttpErrors)\r\n  }\r\n\r\n}\r\n\r\nexport default new DataFacade();\r\n"]},"metadata":{},"sourceType":"module"}